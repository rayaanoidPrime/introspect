import os
from typing import Optional

import uuid
from fastapi import APIRouter
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.sql import select
from db_models import (
    OracleReports,
)
from db_config import engine
from auth_utils import validate_user
from defog.llm.utils import chat_async

router = APIRouter()


class BasicRequest(BaseModel):
    """
    Basic request model for identifying the user and the db name.
    """

    db_name: str
    token: str

    model_config = {
        "json_schema_extra": {
            "examples": [{"db_name": "my_db_name", "token": "my_token"}]
        }
    }


class ReportRequest(BasicRequest):
    """
    Request model for identifying the report to be accessed / modified.
    """

    report_id: int

    model_config = {
        "json_schema_extra": {"examples": [{"db_name": "my_db_name", "report_id": 1}]}
    }


class ReportAnalysisRequest(ReportRequest):
    """
    Request model for requesting a specific analysis of a report.
    """

    analysis_id: str

    model_config = {
        "json_schema_extra": {
            "examples": [{"db_name": "my_db_name", "report_id": 1, "analysis_id": 1}]
        }
    }


@router.post("/oracle/list_reports")
async def reports_list(req: BasicRequest):
    """
    Get the list of reports that have been generated by the user, including
    those in progress. Returns a list of dictionaries, each containing:
    - report_id
    - report_name
    - status
    - date_created
    """
    if not (await validate_user(req.token)):
        return JSONResponse(status_code=401, content={"error": "Unauthorized"})

    async with AsyncSession(engine) as session:
        async with session.begin():
            stmt = (
                select(
                    OracleReports.report_id,
                    OracleReports.report_name,
                    OracleReports.status,
                    OracleReports.created_ts,
                    OracleReports.inputs,
                    OracleReports.is_public,
                    OracleReports.public_uuid,
                )
                .where(OracleReports.db_name == req.db_name)
                .order_by(OracleReports.created_ts.desc())
            )
            result = await session.execute(stmt)
            reports = result.fetchall()

    reports_list = []
    for report in reports:
        status = report.status.value or ""
        is_revision = status.startswith("Revision: ")
        is_being_revised = status.startswith("Revision in progress: ")
        if is_revision:
            continue
        
        # Check if report is public and has a UUID
        is_public = report.is_public or False
        public_url = f"/report?id={report.public_uuid}" if is_public and report.public_uuid else None
        
        reports_list.append(
            {
                "report_id": report.report_id,
                "report_name": report.report_name,
                "status": report.status.value,
                "is_revision": is_revision,
                "is_being_revised": is_being_revised,
                "date_created": report.created_ts.isoformat(),  # Convert to ISO 8601 string
                "inputs": report.inputs,
                "is_public": is_public,
                "public_url": public_url,
            }
        )

    return JSONResponse(status_code=200, content={"reports": reports_list})


@router.post("/oracle/delete_report")
async def delete_report(req: ReportRequest):
    """
    Given a report_id, this endpoint will delete the report from the system.
    Reports in progress will have their associated background tasks cancelled.
    """
    if not (await validate_user(req.token)):
        return JSONResponse(status_code=401, content={"error": "Unauthorized"})
    report = None

    async with AsyncSession(engine) as session:
        async with session.begin():
            stmt = select(OracleReports).where(
                OracleReports.db_name == req.db_name,
                OracleReports.report_id == req.report_id,
            )
            result = await session.execute(stmt)
            report = result.scalar_one_or_none()
            if report:
                await session.delete(report)

    if report:
        return JSONResponse(status_code=200, content={"message": "Report deleted"})
    else:
        return JSONResponse(status_code=404, content={"error": "Report not found"})


@router.post("/oracle/get_report_mdx")
async def get_report_mdx(req: ReportRequest):
    """
    Given a report_id, this endpoint will return the MDX string for the report stored in the postgres db.

    Will return status 400 if no string is found.
    """
    if not (await validate_user(req.token)):
        return JSONResponse(status_code=401, content={"error": "Unauthorized"})

    async with AsyncSession(engine) as session:
        async with session.begin():
            stmt = select(OracleReports).where(
                OracleReports.db_name == req.db_name,
                OracleReports.report_id == req.report_id,
            )
            result = await session.execute(stmt)
            report = result.scalar_one_or_none()

            if report:
                analyses = report.analyses or []
                thinking_steps = report.thinking_steps or []
                report_with_citations = report.report_content_with_citations or []

                non_sql_thinking_steps = [step for step in thinking_steps if step["function_name"] != "text_to_sql_tool"]
                for idx in range(len(non_sql_thinking_steps)):
                    # add the analysis_id to the step
                    # if result is a dict, add the analysis_id to the step
                    if isinstance(non_sql_thinking_steps[idx]["result"], dict):
                        non_sql_thinking_steps[idx]["analysis_id"] = non_sql_thinking_steps[idx]["result"].get("analysis_id", "unknown")
                
                # Include public status information
                public_url = f"/report?id={report.public_uuid}" if report.is_public and report.public_uuid else None
                
                return JSONResponse(
                    status_code=200,
                    content={
                        "mdx": report.mdx,
                        "analyses": analyses + non_sql_thinking_steps,
                        "report_with_citations": report_with_citations,
                        "inputs": report.inputs,
                        "is_public": report.is_public,
                        "public_uuid": report.public_uuid,
                        "public_url": public_url,
                    },
                )
            else:
                return JSONResponse(
                    status_code=404,
                    content={"error": "Report not found"},
                )


class UpdateReportMDXRequest(ReportRequest):
    """
    Request model for updating the MDX string for a report. This will allow us to update both the initially generated mdx and the tiptap's edited mdx.

    We separate the two because we want to keep the original mdx for exporting/revision purposes later on.
    """

    mdx: Optional[str] = None
    tiptap_mdx: Optional[str] = None

    model_config = {
        "json_schema_extra": {
            "examples": [{"db_name": "my_db_name", "report_id": 1, "mdx": "MDX string"}]
        }
    }


@router.post("/oracle/get_report_analysis_ids")
async def get_report_analysis_ids(req: ReportRequest):
    """
    Given a report_id, this endpoint will return the list of analyses ids for the report.
    """
    if not (await validate_user(req.token)):
        return JSONResponse(status_code=401, content={"error": "Unauthorized"})

    async with AsyncSession(engine) as session:
        async with session.begin():
            stmt = select(OracleReports).where(
                OracleReports.db_name == req.db_name,
                OracleReports.report_id == req.report_id,
            )
            result = await session.execute(stmt)
            result = result.scalar_one_or_none()
            if not result:
                return JSONResponse(
                    status_code=404, content={"error": "Report not found"}
                )

            analyses = result.analysis_ids

            return JSONResponse(status_code=200, content={"analyses": analyses})


@router.post("/oracle/get_report_status")
async def get_report_status(req: ReportRequest):
    """
    Given a report_id, this endpoint will return the status of the report.
    """
    if not (await validate_user(req.token)):
        return JSONResponse(status_code=401, content={"error": "Unauthorized"})

    # get the report
    async with AsyncSession(engine) as session:
        async with session.begin():
            stmt = select(OracleReports).where(
                OracleReports.db_name == req.db_name,
                OracleReports.report_id == req.report_id,
            )
            result = await session.execute(stmt)
            row = result.scalar_one_or_none()
            if row:
                return JSONResponse(
                    status_code=200,
                    content={"status": row.status},
                )
            return JSONResponse(status_code=404, content={"error": "Report not found"})


@router.post("/oracle/get_report_comments")
async def get_report_comments(req: ReportRequest):
    """
    Given a report_id, this endpoint will return the comments for the report.
    """
    if not (await validate_user(req.token)):
        return JSONResponse(status_code=401, content={"error": "Unauthorized"})

    async with AsyncSession(engine) as session:
        async with session.begin():
            stmt = select(OracleReports).where(
                OracleReports.db_name == req.db_name,
                OracleReports.report_id == req.report_id,
            )
            result = await session.execute(stmt)
            report = result.scalar_one_or_none()
            if report:
                return JSONResponse(
                    status_code=200, content={"comments": report.comments}
                )
            else:
                return JSONResponse(
                    status_code=404,
                    content={"error": "Report not found"},
                )


class UpdateReportCommentsRequest(ReportRequest):
    """
    Request model for updating the comments for a report.
    """

    comments: list

    model_config = {
        "json_schema_extra": {
            "examples": [
                {"db_name": "my_db_name", "report_id": 1, "comments": "Comments"}
            ]
        }
    }


class TogglePublicStatusRequest(ReportRequest):
    """
    Request model for toggling the public status of a report.
    """

    make_public: bool

    model_config = {
        "json_schema_extra": {
            "examples": [
                {"db_name": "my_db_name", "report_id": 1, "make_public": True}
            ]
        }
    }


@router.post("/oracle/update_report_comments")
async def update_report_comments(req: UpdateReportCommentsRequest):
    """
    Given a report_id, this endpoint will update the comments for the report.
    """
    if not (await validate_user(req.token)):
        return JSONResponse(status_code=401, content={"error": "Unauthorized"})

    async with AsyncSession(engine) as session:
        async with session.begin():
            stmt = select(OracleReports).where(
                OracleReports.db_name == req.db_name,
                OracleReports.report_id == req.report_id,
            )
            result = await session.execute(stmt)
            report = result.scalar_one_or_none()

            if report:
                report.comments = req.comments
                return JSONResponse(
                    status_code=200, content={"message": "Comments updated"}
                )
            else:
                return JSONResponse(
                    status_code=404,
                    content={"error": "Report not found"},
                )


@router.post("/oracle/toggle_public_status")
async def toggle_public_status(req: TogglePublicStatusRequest):
    """
    Toggle the public status of a report.
    
    If making public:
    - Generates a UUID for public access if one doesn't exist
    - Sets is_public flag to True
    
    If making private:
    - Sets is_public flag to False
    - Keeps the UUID for future use
    
    Returns the public URL path if made public.
    """
    if not (await validate_user(req.token)):
        return JSONResponse(status_code=401, content={"error": "Unauthorized"})
    
    async with AsyncSession(engine) as session:
        async with session.begin():
            stmt = select(OracleReports).where(
                OracleReports.db_name == req.db_name,
                OracleReports.report_id == req.report_id,
            )
            result = await session.execute(stmt)
            report = result.scalar_one_or_none()
            
            if not report:
                return JSONResponse(
                    status_code=404,
                    content={"error": "Report not found"},
                )
            
            report.is_public = req.make_public
            
            # Generate a UUID if making the report public and one doesn't already exist
            if req.make_public and not report.public_uuid:
                report.public_uuid = str(uuid.uuid4())
            
            # The session.commit() is handled automatically by the context manager
            
            # Get values before the session is closed
            is_public = report.is_public
            public_uuid = report.public_uuid
            
    # Return responses after session is closed
    if req.make_public:
        return JSONResponse(
            status_code=200,
            content={
                "message": "Report is now public",
                "public_uuid": public_uuid,
                "public_url": f"/report?id={public_uuid}",
            },
        )
    else:
        return JSONResponse(
            status_code=200,
            content={"message": "Report is now private"},
        )


@router.get("/public/report/{public_uuid}")
async def get_public_report(public_uuid: str):
    """
    Retrieve a report by its public UUID. This endpoint doesn't require authentication
    and can be accessed by anyone with the UUID.
    
    Only returns reports that have the is_public flag set to True.
    
    Returns a simplified version of the report's content without interactive elements.
    """
    async with AsyncSession(engine) as session:
        async with session.begin():
            stmt = select(OracleReports).where(
                OracleReports.public_uuid == public_uuid,
                OracleReports.is_public == True
            )
            result = await session.execute(stmt)
            report = result.scalar_one_or_none()
            
            if not report:
                return JSONResponse(
                    status_code=404,
                    content={"error": "Report not found or is not public"},
                )
            
            # Return a simplified version of the report
            report_data = {
                "report_name": report.report_name,
                "created_ts": report.created_ts.isoformat(),
                "mdx": report.mdx,
                "report_content_with_citations": report.report_content_with_citations,
                "analyses": report.analyses
            }
            
            return JSONResponse(
                status_code=200,
                content={"report": report_data},
            )


@router.post("/oracle/export_podcast")
async def export_podcast(req: ReportRequest):
    """
    Given a report_id, this endpoint will convert the report's MDX content into 
    a podcast transcript format between two people using an LLM.
    
    Returns a transcript string that can be saved as a text file.
    """
    if not (await validate_user(req.token)):
        return JSONResponse(status_code=401, content={"error": "Unauthorized"})
    
    async with AsyncSession(engine) as session:
        async with session.begin():
            stmt = select(OracleReports).where(
                OracleReports.db_name == req.db_name,
                OracleReports.report_id == req.report_id,
            )
            result = await session.execute(stmt)
            report = result.scalar_one_or_none()
            
            if not report:
                return JSONResponse(
                    status_code=404,
                    content={"error": "Report not found"},
                )
            
            mdx = report.mdx
            
            if not mdx:
                return JSONResponse(
                    status_code=400,
                    content={"error": "Report has no content to convert"},
                )
            
            # Prepare system and user prompts for the LLM
            system_prompt = """
You are an expert at converting data analysis reports into engaging podcast transcripts.
Your task is to transform a technical report into a natural conversation between two hosts.:

- Ana: A data analyst who explains the findings in an accessible way
- Mike: A curious co-host who asks clarifying questions and helps emphasize key points

Follow these guidelines:
1. Maintain the same information and insights from the original report
2. Create a conversational flow that covers all the main points in detail
3. Include a brief introduction and conclusion
4. Use natural language that would sound authentic in a spoken conversation
5. Avoid technical jargon unless Ana explicitly explains it
6. Format the transcript as:
    Ana: [Ana's dialogue]
    Mike: [Mike's dialogue]
"""
            
            user_prompt = f"""
Please convert the following report content into a podcast transcript between Ana and Mike.
Start with an introduction where they welcome the listeners and briefly explain what they'll cover.
End with a conclusion summarizing the key takeaways.

Here's the report content:

{mdx}
"""
            
            # Call the LLM to generate the podcast transcript
            messages = [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt},
            ]
            
            try:
                response = await chat_async(
                    provider="gemini",
                    messages=messages,
                    model="gemini-2.5-pro-exp-03-25",
                    max_completion_tokens=8191,
                    temperature=0.5,
                    timeout=200,
                )
                
                podcast_transcript = response.content
                
                return JSONResponse(
                    status_code=200,
                    content={"transcript": podcast_transcript},
                )
            except Exception as e:
                return JSONResponse(
                    status_code=500,
                    content={"error": f"Error generating podcast transcript: {str(e)}"},
                )
